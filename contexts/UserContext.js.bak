import React, { createContext, useContext, useState, useEffect, useRef } from 'react';
import { View, Text } from 'react-native';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { auth, db } from '../firebase';
import { 
  onAuthStateChanged, 
  signOut as firebaseSignOut,
  onIdTokenChanged
} from 'firebase/auth';
import { 
  collection, 
  query, 
  where, 
  getDocs, 
  doc, 
  getDoc, 
  setDoc, 
  updateDoc, 
  serverTimestamp 
} from 'firebase/firestore';

const UserContext = createContext();

export const UserProvider = ({ children }) => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [authChecked, setAuthChecked] = useState(false);
  const isMounted = useRef(true);

  // Set up auth state listener with retry logic
  useEffect(() => {
    let isEffectMounted = true;
    let retryCount = 0;
    const maxRetries = 3;
    let retryTimeout;
    
    const setupAuthListener = () => {
      let unsubscribe = () => {}; // Default empty cleanup function
      let isSubscribed = true;
      let cleanupRetryTimeout = null;
      
      const cleanup = () => {
        isEffectMounted = false;
        isSubscribed = false;
        if (typeof unsubscribe === 'function') {
          unsubscribe();
        }
        if (cleanupRetryTimeout) {
          clearTimeout(cleanupRetryTimeout);
        }
      };
      
      const execute = async () => {
        if (!isEffectMounted || !isSubscribed) return;
        
        try {
          // Try to load cached data first for better UX
          try {
            const cachedUser = await AsyncStorage.getItem('userData');
            if (cachedUser) {
              console.log('Using cached user data');
              setUser(JSON.parse(cachedUser));
            }
          } catch (error) {
            console.warn('Failed to load cached user data:', error);
          }

          // Set up the auth state listener
          const authListenerCleanup = onAuthStateChanged(auth, 
            // Success callback
            async (firebaseUser) => {
              if (!isEffectMounted) return;
              
              try {
                setLoading(true);
                
                if (firebaseUser) {
                  console.log('ğŸ”‘ User authenticated:', firebaseUser.uid);
                  
                  // Try to get user data from Firestore
                  let additionalUserData = {};
                  let userDoc;
                  
                  try {
                    // First try to get by UID (recommended)
                    userDoc = await getDoc(doc(db, 'users', firebaseUser.uid));
                    
                    if (userDoc.exists()) {
                      additionalUserData = userDoc.data();
                      console.log('âœ… Found user data by UID');
                    } else {
                      // Fallback: Try to get by email (for backward compatibility)
                      console.log('â„¹ï¸ No user data found by UID, trying email...');
                      const usersRef = collection(db, 'users');
                      const q = query(usersRef, where('email', '==', firebaseUser.email));
                      const querySnapshot = await getDocs(q);
                      
                      if (!querySnapshot.empty) {
                        additionalUserData = querySnapshot.docs[0].data();
                        console.log('âœ… Found user data by email');
                      }
                    }
                  } catch (dbError) {
                    console.warn('âš ï¸ Database error, using available data:', dbError.message);
                    // Continue with available data
                  }
                  
                  // Create user data object with fallbacks
                  const userData = {
                    uid: firebaseUser.uid,
                    email: firebaseUser.email,
                    emailVerified: firebaseUser.emailVerified,
                    name: additionalUserData?.name || firebaseUser.displayName || firebaseUser.email?.split('@')[0] || 'User',
                    profilePic: additionalUserData?.profilePic || firebaseUser.photoURL || null,
                    username: additionalUserData?.username || firebaseUser.email?.split('@')[0] || 'user',
                    studentID: additionalUserData?.studentID || '',
                    mobile: additionalUserData?.mobile || '',
                    address: additionalUserData?.address || '',
                    bio: additionalUserData?.bio || '',
                    role: additionalUserData?.role || 'student',
                    createdAt: additionalUserData?.createdAt || serverTimestamp(),
                    updatedAt: serverTimestamp(),
                  };
                  
                  // Update state
                  setUser(userData);
                  
                  // Cache user data
                  try {
                    await AsyncStorage.setItem('userData', JSON.stringify(userData));
                  } catch (storageError) {
                    console.warn('âš ï¸ Failed to cache user data:', storageError.message);
                  }
                  
                  // Update last login time (don't block on this)
                  if (userDoc?.exists()) {
                    updateDoc(doc(db, 'users', firebaseUser.uid), {
                      lastLogin: serverTimestamp()
                    }).catch(e => console.warn('âš ï¸ Failed to update last login:', e.message));
                  }
                  
                  console.log('âœ… User data loaded successfully');
                  retryCount = 0; // Reset retry count on success
                } else {
                  console.log('ğŸ‘‹ No user signed in');
                  setUser(null);
                  try {
                    await AsyncStorage.removeItem('userData');
                  } catch (e) {
                    console.warn('âš ï¸ Failed to clear cached user data:', e.message);
                  }
                }
              } catch (error) {
                console.error('âŒ Auth state change error:', error);
                
                // If it's a network error, try to use cached data
                if (error.code === 'auth/network-request-failed' || error.code === 'unavailable') {
                  console.log('ğŸŒ Network error - trying to use cached data');
                  try {
                    const cachedUser = await AsyncStorage.getItem('userData');
                    if (cachedUser) {
                      console.log('ğŸ“¦ Using cached user data');
                      setUser(JSON.parse(cachedUser));
                    } else if (retryCount < maxRetries) {
                      // Exponential backoff for retries
                      const delay = Math.min(1000 * Math.pow(2, retryCount), 30000);
                      console.log(`ğŸ”„ Retrying in ${delay}ms... (Attempt ${retryCount + 1}/${maxRetries})`);
                      retryCount++;
                      retryTimeout = setTimeout(() => {
                        setupAuthListener();
                      }, delay);
                      return;
                    }
                  } catch (e) {
                    console.warn('âš ï¸ Error handling network failure:', e.message);
                  }
                }
              } finally {
                if (isMounted) {
                  setLoading(false);
                  setAuthChecked(true);
                }
              }
            },
            // Error callback
            (error) => {
              console.error('âŒ Auth state listener error:', error);
              if (isMounted && retryCount < maxRetries) {
                const delay = Math.min(1000 * Math.pow(2, retryCount), 30000);
                console.log(`ğŸ”„ Retrying auth listener in ${delay}ms... (Attempt ${retryCount + 1}/${maxRetries})`);
                retryCount++;
                retryTimeout = setTimeout(() => {
                  setupAuthListener();
                }, delay);
              }
            }
          );
          
          // Simple retry mechanism without network detection
          const retryConnection = () => {
            if (!isMounted || !isSubscribed || retryCount >= maxRetries) return;
            
            const delay = Math.min(1000 * Math.pow(2, retryCount), 30000);
            console.log(`ğŸ”„ Will retry in ${delay}ms... (Attempt ${retryCount + 1}/${maxRetries})`);
            retryCount++;
            
            cleanupRetryTimeout = setTimeout(() => {
              if (isMounted && isSubscribed) {
                execute();
              }
            }, delay);
          };
          
          return cleanup;
          
        } catch (error) {
          console.error('Error in auth listener:', error);
          if (isMounted && isSubscribed) {
            setLoading(false);
            setAuthChecked(true);
            retryConnection();
          }
        }
      };
      
      // Start the listener
      execute();
      
      // Return cleanup function
      return cleanup;
    };
    
    // Set up the auth listener and return cleanup function
    return setupAuthListener();
  }, []);

  /**
   * Save user data to Firestore and update local state
   * @param {Object} userData - User data to save
   * @returns {Promise<boolean>} True if successful, false otherwise
   */
  const saveUserData = async (userData) => {
    if (!isEffectMounted) return false;
    
    try {
      if (!userData?.email) {
        throw new Error('Cannot save user data: No email provided');
      }
      
      console.log('ğŸ’¾ Saving user data for:', userData.email);
      
      // Prepare user data for Firestore
      const userToSave = {
        ...userData,
        updatedAt: serverTimestamp(),
        lastLogin: new Date().toISOString(),
        email: userData.email.toLowerCase().trim()
      };

      // Save to Firestore
      const userRef = doc(db, 'users', userToSave.email);
      await setDoc(userRef, userToSave, { merge: true });
      console.log('âœ… User data saved to Firestore');

      // Update local state
      setUser(prev => ({
        ...prev,
        ...userToSave
      }));
      
      return true;
    } catch (error) {
      console.error('âŒ Error saving user data:', {
        error: error.message,
        code: error.code,
        stack: error.stack
      });
      return false;
    }
  };

  /**
   * Clear user data on logout
   * @returns {Promise<boolean>} True if successful, false otherwise
   */
  const clearUserData = async () => {
    if (!isMounted.current) return false;
    
    try {
      console.log('ğŸšª Starting user sign out process...');
      setLoading(true);
      
      // Clear local state first to update UI immediately
      setUser(null);
      
      try {
        // Clear any cached data
        await AsyncStorage.multiRemove(['userData', 'authToken']);
        console.log('âœ… Cleared local storage data');
      } catch (storageError) {
        console.warn('âš ï¸ Failed to clear local storage:', storageError);
        // Continue with sign out even if clearing storage fails
      }
      
      // Sign out from Firebase Auth
      if (auth.currentUser) {
        console.log('ğŸ”’ Signing out from Firebase...');
        try {
          await firebaseSignOut(auth);
          console.log('âœ… Successfully signed out from Firebase');
        } catch (signOutError) {
          console.error('âŒ Error signing out from Firebase:', signOutError);
          // Even if sign out fails, we want to clear the local state
          return false;
        }
        console.log('ğŸ‘‹ User signed out from Firebase Auth');
      }
      
      // Clear local storage
      await AsyncStorage.multiRemove(['userData']);
      
      // Reset state
      setUser(null);
      
      console.log('âœ… User data cleared successfully');
      return true;
    } catch (error) {
      console.error('âŒ Error clearing user data:', {
        error: error.message,
        code: error.code
      });
      return false;
    }
  };

  // Only render children once auth state is checked
  // This prevents flash of unauthenticated content
  const shouldRenderChildren = !loading || authChecked;
  
  // Prepare context value
  const contextValue = {
    user,
    isAuthenticated: !!user,
    isLoading: loading,
    isAuthChecked: authChecked,
    saveUserData,
    clearUserData
  };

  if (__DEV__) {
    console.log('ğŸ”„ UserContext render', {
      user: user ? 'authenticated' : 'not authenticated',
      loading,
      authChecked
    });
  }

  return (
    <UserContext.Provider value={contextValue}>
      {shouldRenderChildren ? children : null}
    </UserProvider>
  );
};

/**
 * Custom hook to access the user context
 * @returns {Object} The user context containing { user, saveUserData, clearUserData, loading }
 * @throws Will throw an error if used outside of a UserProvider
 */
export const useUser = () => {
  const context = useContext(UserContext);
  const isInitialMount = useRef(true);
  
  // Debug log to help track hook usage (development only)
  useEffect(() => {
    if (__DEV__) {  // Only log in development
      if (context?.user) {
        console.log('âœ… useUser: User authenticated -', context.user.email);
      } else if (context && !context.loading) {
        console.log('â„¹ï¸ useUser: No active user session');
      }
      
      // Log only on first mount
      if (isInitialMount.current) {
        console.log('ğŸ” useUser: Hook initialized');
        isInitialMount.current = false;
      }
    }
  }, [context]);

  // Provide default values if context is not available
  if (!context) {
    if (__DEV__) {
      console.warn('âš ï¸ useUser was called outside of a UserProvider. Using default values.');
    }
    return {
      user: null,
      isAuthenticated: false,
      isLoading: false,
      isAuthChecked: false,
      saveUserData: async () => {
        console.warn('saveUserData was called outside of a UserProvider');
        return false;
      },
      clearUserData: async () => {
        console.warn('clearUserData was called outside of a UserProvider');
        return false;
      }
    };
  }

  return context;
};

export default UserContext;
